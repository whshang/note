# 上下文管理技巧：如何在不浪费 token 的情况下提供必要信息

使用 AI 时，我经常遇到两个问题：上下文不够，AI 说"信息不足，无法回答"；或者上下文太多，AI 被无关信息干扰，给出错误答案。

经过几个月的摸索，我学会了在不浪费 token 的情况下提供必要信息。

## 第一个误区：一股脑提供所有信息

我想让 AI 修改一个函数，于是我把整个项目的代码都发给了 AI：package.json（100 行）、main.js（500 行）、utils.js（200 行）、config.js（150 行），还有 README.md、CONTRIBUTING.md 等。总共 2000+ 行代码。

AI 回答：代码太复杂，无法分析；或者建议简化后再提问；或者给出了完全无关的建议。

问题在哪？

信息过载。AI 被大量无关信息淹没，无法找到关键信息。

token 浪费。大部分信息 AI 根本没用到，占用了宝贵的上下文窗口。

注意力分散。AI 不知道该关注哪部分。

## 第二个误区：信息太少

吸取教训后，我只给关键部分："请修改这个函数：function foo() { return 1; }"

AI 给出了修改建议，但不知道这个函数在整个项目中的作用，不了解项目的编码规范，修改后与其他部分不兼容。

信息太少导致 AI 缺少必要的上下文。

## 现在的做法：结构化上下文管理

经过多次试错，我总结了一个上下文管理框架。

### 框架模板

```
【核心信息】: [AI 必须知道的关键内容]
【上下文信息】: [有助于理解但非必需的信息]
【约束信息】: [必须遵守的规则和规范]
【排除信息】: [AI 不需要知道的无关内容]
```

### 实际应用

用上面的函数修改例子，我现在的做法：

```
【核心信息】: 需要修改的函数代码、修改的具体要求
【上下文信息】: 这个函数在用户认证模块中、返回值会被用于权限检查
【约束信息】: 必须保持向后兼容、需要添加错误处理、遵循项目编码规范（ESLint）
【排除信息】: package.json（除非涉及依赖）、其他模块的代码、文档文件
```

然后我给 AI 的信息是：

```
【项目上下文】: 这是用户认证模块，用于权限检查
【核心代码】:
function validateUser(user) {
  if (!user) return false;
  return user.isActive && user.role === 'admin';
}
【修改要求】: 添加对用户过期时间的检查，如果用户过期则返回 false
【约束条件】:
- 保持向后兼容
- 添加错误处理
- 遵循 ESLint 规范
```

AI 能准确理解需求，并给出符合项目规范的修改建议。

## 几个技巧

### 信息分层

将信息按重要性分层。Layer 1（必须）：核心代码 + 具体要求。Layer 2（重要）：上下文 + 约束。Layer 3（可选）：相关代码片段。Layer 4（排除）：无关文件。

### 精确引用

不要发送整个文件，只发送相关部分。

错误做法：发送整个 utils.js 文件（200 行）。

正确做法：发送相关函数：
```
function formatDate(date) {
  // ...
}
function parseDate(str) {
  // ...
}
```

### 上下文摘要

对于复杂的项目，提供摘要而不是原文。

项目结构：src/auth/（认证相关）、src/api/（API 调用）、src/utils/（工具函数）。

编码规范：使用 ESLint、异步函数用 async/await、错误处理用 try/catch。

### 动态调整

根据 AI 的反馈调整上下文。如果 AI 说"信息不足"，添加更多上下文信息。如果 AI 给出无关建议，减少无关信息。如果 AI 理解错误，添加澄清信息。

## 实战案例

### 重构大型组件

之前（信息过载）：发送整个 React 项目（5000+ 行），AI 无法找到重点。

现在（结构化）：

```
【核心组件】: UserList.jsx (150 行，只发送关键部分)
【上下文】: 这是管理员页面，用于管理用户
【问题】: 组件性能差，渲染 1000+ 用户时卡顿
【约束】:
- 不能改变 API 接口
- 需要保持现有 UI
- 使用 React.memo 优化
【相关代码】:
- UserService.js (API 调用部分)
- UserItem.jsx (子组件)
```

AI 准确识别性能问题并给出优化建议。

## 检查清单

每次给 AI 提供信息前，我会检查：

核心信息是否足够？（AI 能完成任务）

上下文信息是否必要？（有助于理解）

约束信息是否明确？（规则和规范）

是否有无关信息？（可以排除的）

token 是否在限制内？（不超过上下文窗口）

## 进阶技巧

### 上下文复用

对于连续对话，可以复用之前的上下文。后续问题："基于刚才的修改，现在还需要添加缓存功能"。

### 上下文更新

当项目发生变化时，及时更新上下文。比如："提醒：刚才我修改了 API 接口，现在 getUserInfo 返回字段有变化"。

### 上下文清理

定期清理过时的上下文。比如："忽略之前关于旧 API 的讨论，我们现在使用新接口"。

## 最后想说

上下文管理的核心是信息的有效性。不是信息越多越好，而是有用信息的比例越高越好。关键是要知道 AI 需要什么信息。

好的上下文管理，关键在精确、结构化、相关性、动态调整。

这套方法让我减少了 70% 的 token 浪费，同时提高了 AI 的准确性。
